#!/bin/bash

__prompt_git_info() {
  __git_branch_name() {
    ref=$(git symbolic-ref --short HEAD 2> /dev/null) || return
    echo $ref
  }

  __git_is_dirty() { # "" on no changes, content if changes
    echo $(git status --porcelain 2>/dev/null)
  }

  __git_has_upstream() { # returns "x y" where x is # of commits ahead, y is # of commits in origin
    echo $(git rev-list --left-right --count 'HEAD...@{upstream}' 2>/dev/null)
  }

  local DIRTY_CHAR=$GRAY
  if [[ "$(__git_is_dirty)" != "" ]]
  then
    DIRTY_CHAR="$YELLOW*"
  fi

  local changes=$(__git_has_upstream | cut -d" " -f1)
  local UP_CH=""
  if [[  changes -gt 0 ]]
  then
    UP_CH="(+)"
  fi

  echo "$DIRTY_CHAR$(__git_branch_name)$UP_CH"
}

__prompt_command() {
  status="$?"
  PS1=""

  GRAY="\[\e[90m\]"
  YELLOW="\[\e[33m\]"
  CYAN="\[\e[36m\]"
  RED="\[\e[31m\]"
  RESET="\[\e[39m\]"

  __exists () {
    type $1 &> /dev/null ;
  }

  __str_len() {
    echo $(echo -e "$@" | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" | wc -m)
  }

  __pwd() {
    if __exists short_pwd
    then
      short_pwd $(expr $COLUMNS - $(__str_len $@) - 5)
    else
      echo "\w"
    fi
  }

  prompt_time=$(date +"%H$YELLOW:$RESET%M")
  prompt_git="$(__prompt_git_info)"  # ... hard.
  prompt_mode="" # can't set vi mode :(
  prompt_cwd="$CYAN$(__pwd $prompt_time)$RESET"
  prompt_symbol="$"

  if [ $status -ne 0 ] 
  then 
    prompt_symbol="$RED$prompt_symbol$RESET"
  fi

  PS1="\n$prompt_time $prompt_cwd $prompt_git$RESET\n$prompt_symbol$RESET "

  # cleanup
  unset __pwd
  unset __str_len
  
  unset YELLOW
  unset CYAN
  unset RED
  unset GRAY
  unset RESET
}

PROMPT_COMMAND+="__prompt_command;"

